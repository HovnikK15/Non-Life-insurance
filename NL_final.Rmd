---
title: "Non-Life Insurance - Final project"
output: html_document
author: "Klemen Hovnik and Manca Strgar"
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r packages,  include=FALSE, warning = FALSE, message = FALSE}
#package instalation:
packages <- c("tidyverse", "mgcv", "evtree", "classInt", "rgdal", "RColorBrewer", "grid", "gridExtra", "visreg", "sf", "tmap", "rgeos", "mapview", "leaflet", "rmarkdown", "ggplot2", "kableExtra")
suppressMessages(packages <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x)
    library(x, character.only = TRUE)
  }
  else {
  message("Everything is set up correctly. You are ready to go.")
}
}))

#libraries:
library(dplyr)
library(knitr)
library(rmarkdown)
library(tidyverse)
library(ggplot2)
library(graphics)
library(here)
library(gridExtra)
library(mgcv)
library(evtree)
library(classInt)
library(rgdal)
library(RColorBrewer)
library(grid)
library(visreg)
library(sf)
library(tmap)
library(rgeos)
library(mapview)
library(leaflet)
library(kableExtra)
library(DT)
library(formattable)

```
PART 1
=======

# 1 Importing dataset

First, we need to import data from the file `Assignment.csv` into R. The file contains 163,657 rows with 16 variables. Every row represents an individual policyholder in our portfolio. One of most important columns are `nbrtotc`(number of claims for indiviudual policyholder) and `chargtot` (value of all claims for individual policyholder) as they represent frequency and severity, the amounts we are gpint to be fitting with models in this project.
Let's have a look at our dataset:

```{r, echo=F}
mtpl_orig <- read.csv("Assignment.csv", header = TRUE)
mtpl_orig=as_tibble(mtpl_orig)
kable(head(mtpl_orig), align = "c")


```

As it can be seen our column names are not formated. So, we could rename colums in our dataset to make it easier to work with. We will rename the column `nbrtotc` into `nclaims` as the number of claims, and `duree` into `expo` as exposure. For easier programming we will also rename `ageph` and `sexp` into `age` and `sex`. We aslo renamed `chargtot` into `amount`. For further analysis we will also replace `0` with `NA` in `amount` column, because we will need this kind of formatting for when we will try to fit severity later on.

```{r, echo=F}
mtpl <- mtpl_orig %>%
  # rename all columns 
  rename_all(function(.name) {
    .name %>% 
      # replace all names with the lowercase versions
      tolower 
    })
mtpl <- rename(mtpl, age= ageph, sex = sexp, nclaims = nbrtotc, expo = duree,
               amount = chargtot)
mtpl$amount[mtpl$amount == 0] <- NA 
kable(head(mtpl), align = "c")
```

# 2 Empirical analysis

For the begining of our empirical analysis, we will calculate the empirical claim frequency. Empirical claim frequency rate is the anticipated percentage of insured that will make claims against insurance and the number of claims they will make during a certain period. So we calculate it as 
$$emperical\ claim\ frequency = \frac{\sum{number\ of\ claims}}{\sum{exposure}}$$
 
```{r, echo=F}

kable(head(mtpl %>% summarize(emp_freq = sum(nclaims) / sum(expo)) ))
```

We can see that our empirical claim frequency is low, so we will not expect a large number of claims per individual policyholder in our portfolio.

To have a better understanding of our data we can make a graphic presentation of it.
Column `nclaims` in our data represents the number of claims for every individual in our portfolio. This is a very important information for building our model. We can observe that in majority of the cases we have zero claims per policy. We can also compute the mean and variance of `nclaims`, that will confirm that.

```{r, echo = F, warning=FALSE}
mean1 <- mean(mtpl$nclaims)
var1 <-  sum((mtpl$nclaims - mean1)^2) /length(mtpl$nclaims)
kable(head(c(mean = mean1, variance = var1)), col.names = "nclaims")

```

We see that mean is really close to zero. But to convince you even more, that the majority of the policies have zero claims, we can show you in a graph. Graph below actually shows us that almost 150,000 of policies have zero claims and the number of policies that have more than zero claims is verry low.

```{r, echo=F}
graph1<- ggplot(mtpl, aes(nclaims)) + geom_bar(col = "red", 
              fill = "red", alpha = 0.5) + 
     labs(y = "Abs frequency (in exposure)") +
     ggtitle("MTPL - number of claims")
graph1
```

Looking at this in relative terms, we can see that more than around 90% of insurance contract did not have any claims. So approximatelly 10 % of all policyholders have one or more claims. This is shown in a graph below.

```{r, echo=F}
graph2 <- ggplot(mtpl, aes(nclaims)) + theme_bw()
graph2 + geom_bar(aes(y = (..count..)/sum(..count..)), 
    col = "red", fill = "red", alpha = 0.5) + 
  labs(y = "Relative frequency") +
  ggtitle("MTPL - relative number of claims")
```

We can also group the claims by the gender. In the result below we see that females are in our case more risky, because they have slightly higher mean empirical frequency. Generally speaking this is probably quite unusual, as most of the statistics would show that men are more risky drivers than women.

```{r, echo = F, warning=FALSE, message=FALSE}
freq_by_gen <- mtpl %>%  group_by(sex) %>% summarize(emp_freq = sum(nclaims) / sum(expo))
kable(head(freq_by_gen), align = "c")

```

We played around with `nclaim`, but this is not the only data that we have. So let's graphically show side by side relative frequency for our given data. 
First graph we already seen and it show the relative frequency of claim number. We see, as already discused, that the majority of policyholders have zero claims and as the number of claims rises, the frequency falls. 
The second graph shows the exposure of our policyholders. The exposure represents the fraction of the year that the individual policyholder is insured. We can see, that most of policyholders are ensured for the whole year. 
Third graph shows the severity of the claims. As most of the policyholders have zero claims, it does not come as a surprice that the higher relative frequency for severity is at zero. And also the higher the amount, the lower is the frequency as claims of high altitude rearly happen.
The last graph in firs raw shows that most of policyholders have MTPL coverage, the nsecond most common is MTPL +  and the last MTPL +++.
First graph in second row shows that most of our policyholders drive cars on petrol, only around 30 % of them have cars on gasoil. 
Next graph shows that majority of policyholders in our portfolio are male. 
In seventh graph we can see that almost everyone's cars are for private use not professional. 
Variable feet tells us if the insured car is part of a fleet. We see that most of them are not.
One of most important variable in our data is age. We see that majority of our policyholders are 30 to 50 years old. 
The next variable in the power of the car. From the graph we can see that most of cars have less than 66kW.
The next graph shows as that almost 50 % of the cars are 6 to 10 years old. 
And the last graph shows that most of the cars insured in our portfolio are not sport cars. 

```{r, echo=F, warning=FALSE, message=FALSE}
mtpl$powerc = factor(mtpl$powerc, levels=c("<66", "66-110", ">110"))
mtpl$agecar = factor(mtpl$agecar, levels=c("0-1", "2-5", "6-10", ">10"))
ylab <- "Relative frequency"
ggplot.bar <- function(DT, variable, xlab){
  ggplot(data = DT, aes(as.factor(variable)), environment = environment()) + theme_bw() + 
    geom_bar(aes(y = (..count..)/sum(..count..)), col = "red", fill = "red") + labs(x = xlab, y = ylab)
}
ggplot.hist<- function(DT,variable,xlab,binwidth){
  ggplot(data =DT, aes(variable))+theme_bw()+
    geom_histogram (aes(y =(..count..)/sum(..count..)), binwidth = binwidth, col ="red", fill ="red", alpha = 0.5)+
    labs(x=xlab, y=ylab)
} 

sevirity_plot <- ggplot(data = mtpl, aes(mtpl$amount)) + geom_density(adjust = 3, col = "red", fill = "red") + xlim(0,1e4) + ylab(ylab) + xlab("sevirity") + theme_bw()

grid.arrange(ggplot.bar(mtpl, mtpl$nclaims, "nclaims"),
ggplot.hist(mtpl, mtpl$expo, "expo", NULL),
sevirity_plot,
ggplot.bar(mtpl, mtpl$coverp, "coverage"),
ggplot.bar(mtpl, mtpl$fuelc, "fuel"),
ggplot.bar(mtpl, mtpl$sex, "sex"),
ggplot.bar(mtpl, mtpl$usec, "use"),
ggplot.bar(mtpl, mtpl$fleetc, "fleet"),
ggplot.hist(mtpl, mtpl$age, "age", NULL),
ggplot.bar(mtpl, mtpl$powerc, "power"),
ggplot.bar(mtpl, mtpl$agecar, "car age"),
ggplot.bar(mtpl, mtpl$sportc, "sport car"), ncol =4)
```

Among our data, we also have an information about the postal code of Belgium in which the claim happened. We can show this in a map. We can see that most of the claims happen in urban areas. 

```{r, echo = F, warning=FALSE, message=FALSE, results="hide", fig.show='hide'}

mtpl_pc <- aggregate(mtpl$expo ~ mtpl$codposs, data=mtpl, sum)
names(mtpl_pc)[names(mtpl_pc) == "mtpl$expo"] <- "EXP"
names(mtpl_pc)[names(mtpl_pc) == "mtpl$codposs"] <- "PC"
mtpl_pc$N <- mtpl_pc$EXP

belgium_shape_sf <- st_read('npc96_region_Project1.shp', quiet = TRUE)
belgium_shape_sf <- st_transform(belgium_shape_sf, "+proj=longlat +datum=WGS84")
class(belgium_shape_sf)
belgium_shape_sf %>% as_tibble() %>% select(-geometry) %>% slice(1:3) %>% kable(format="html")
ggplot(belgium_shape_sf) + geom_sf() + ggtitle("Map of Belgium") + theme_bw()
simple_shp <- st_simplify(belgium_shape_sf, dTolerance = 0.00001)
qtm(simple_shp)

tm_shape(simple_shp) +
  tm_borders(col="red", lwd =0.5) +
  tm_layout(main.title = "Map of Belgium",
            legend.outside = TRUE, frame = FALSE)

post_expo <- mtpl %>% group_by(mtpl$codposs) %>% summarize(num=n(), total_expo = sum(mtpl$expo))
post_expo %>% slice(1:5) %>% kable(format = "html")
names(post_expo)[names(post_expo) == "mtpl$codposs"] <- "PC"

belgium_shape_sf <- left_join(belgium_shape_sf, post_expo, by =c("POSTCODE"="PC"))
belgium_shape_sf$freq <- belgium_shape_sf$total_expo/belgium_shape_sf$Shape_Area
belgium_shape_sf$freq_class <- cut(belgium_shape_sf$freq,
    breaks = quantile(belgium_shape_sf$freq, c(0,0.2,0.8,1), na.rm= TRUE),
    right = FALSE, include.lowest = TRUE,
    labels = c("low", "average", "high"))
```
```{r, echo = F, warning=FALSE, message=FALSE}
ggplot(belgium_shape_sf) +
  geom_sf(aes(fill=freq_class),
          colour = "black", size =0.1)+
  ggtitle("MTPL claim frequency data") +
  labs(fill="Relative\nexposure")+
  scale_fill_brewer(palette="Reds",
                     na.value ="white")+
  theme_bw()
```

# 3.2 The construction of a (technical) tariff structure with Generalized Linear Model (GLM)

To construct a (technical) tariff structure we first need to fit frequency and severity of claims in our portfolio. We decided that we will first do this with GLMs. To fit frequency with GLM we can use Poisson or Negative Binomial distribution. The best suitable distributios for severity fitting are Log-normal and Gamma distributions. For our exercise we decided that we will fit frequency with Poisson distribution and Severity with Gamma distribution.

Firs lets build a Poisson GLM for number of claims, so we are building frequency model. We will built a GLM for number of claims as a function of a covariate gender, we will also include the log of exposure as an offset. We will do that with `glm` function.

In `glm` we can define one variable as a function of covariates. In our example we will define `nclaims` as a function of covariate `sex`. As an offset we will include the log of `expo` (log of exposure). Then we need to define which family of distributions we want to use and as said before we will use Poisson distribution, which has a link function logaritmic function. And finally, we need to determine aour data set, which is `mtpl`. 
We can write this as:
$$ Y \sim Poisson\ \ with \\
log(E(Y)) = x'* \beta, or \\
E(Y) = e^{x'*\beta} $$

When we run the code we get the following expected frequencies for female and male.

```{r, echo=F, results = "hide"}
freq_glm_sex <- glm(nclaims ~ sex, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)

freq_glm_sex %>% broom::tidy()

emp_freq_female <- exp(coef(freq_glm_sex)[1])
emp_freq_male <- exp(coef(freq_glm_sex)[1]+coef(freq_glm_sex)[2])    
```

```{r, echo=F}
kable(head(c(Female = emp_freq_female, Male = emp_freq_male)), col.names = "Emp. frequency")
```

Here we modeled number of claims with sex and gor empirical frequency of claims per individual geneder. If we now look back at the begining of our report, we already analysed empirical frequency grouped by the gender. We can see, that we got the same result for empirical frequency by gender, as we did in the first part of the report. This is because we constructed the GLM with only one covariance (sex). If more were used the result would be different. 

In RStudio we also have a `predict` function that alows us to use our GLM model on new data frames. We can now dafine two new data frames, one being male drivers with exposure 1 and the other being the female drivers with exposure 1. And we can use `predict` function on these two new data frames, we only need to yet determin the type of `predict` function. This means that we can do predictions on different levels:
  1.level: "response" ~ we will construct the fitted value of expected value we are ftting (Y from above). We want to know, given the covariates that we observed for our X, what is the fitted value of expected outcome.
  2.level: "terms" ~ This allows us to isolate one specific covariate and it's associated effect. 
  3.level: "link" ~ We calculate the betas, we do not take the inverse of our link function. We will make a transition to the scale of response. 
We will always predict on a level of response, because we are interested in the fitted value of expected outcome.

```{r, echo=F}
male_driver <- data.frame(expo = 1, sex = "Male")
female_driver <- data.frame(expo = 1, sex = "Female")
kable(head(c(Female = predict(freq_glm_sex, newdata = female_driver,    
       type = "response"),
Male = predict(freq_glm_sex, newdata = male_driver, 
       type = "response"))), col.names = "predicted frequency")
```

We can see, that even on new data frame we get the same frequency per gender as before. 

Now we will build a model for sevirity information. For severity, the best distributions for fitting are Gamma and Log-normal distribution. We decided to use Gamma distribution for severity fitting. So for sevirity we will analyse variable `amount` in our mtpl data. We will again use only one explenatory variable sex. 

```{r, echo=F, results="hide"}
 
sev_glm_sex <- glm(amount ~ sex, offset =log(expo),family = Gamma(link = "log"), data =mtpl)
sev_glm_sex
sev_glm_sex %>% broom::tidy()

emp_sev_female <- exp(coef(sev_glm_sex)[1])
emp_sev_male <- exp(coef(sev_glm_sex)[1]+coef(sev_glm_sex)[2])  
```
```{r, echo=F}
kable(head(c(Female = emp_sev_female, Male = emp_sev_male)), col.names = "Emp. sevirity")

```

We can also use `predict` function for severity and calculated empirical severity on before determend new data sets (male and female driver with exposure 1).

```{r, echo=F}
male_driver <- data.frame(expo = 1, sex = "Male")
female_driver <- data.frame(expo = 1, sex = "Female")
kable(head(c(Female = predict(sev_glm_sex, newdata = female_driver,    
       type = "response"),
Male = predict(sev_glm_sex, newdata = male_driver, 
       type = "response"))), col.names = "predicted severity")
```

We can see that also with the `predict` function, we get the same values. 

Now, that we've seen how `glm` and `predict` functions work, let's try to fit frequency (`nclaims`) with our given covariates. We choose 20 different models for our model fitting. Chosen models are shown in the table below. But we also need to determen which criteria we will use to determine the best model. We decided that as a criteria we will use AIC. 

The Akaike information criterion (AIC) is an estimator of prediction error and  provides relative quality of statistical models for a given set of data. AIC estimates the quality of each model which we can relative compare to each of the other models.The preferred model is the one with the minimum AIC value. We will use already build in functin `AIC` to determin the AIC value for every chosen model.

```{r, echo=F, results="hide", fig.show='hide'}
freq_glm_1 <- glm(nclaims ~ age + sex + codposs + agecar + fuelc + split + usec + fleetc + sportc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_1) #AIC = 126165.7

freq_glm_2 <- glm(nclaims ~ age + codposs + agecar + fuelc + split + usec + fleetc + sportc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_2) #AIC = 126168.5 model 1 is a better fit

freq_glm_3 <- glm(nclaims ~ age + sex + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_3) #AIC = 1126164.5 this model is a better fit

freq_glm_4 <- glm(nclaims ~ age + sex + age:sex + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_4) #AIC = 126144.1 this model is a better fit

freq_glm_5<- glm(nclaims ~ age + sex + age:sex + age:powerc + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_5) #AIC = 126145.7 model 4 is  a better fit

freq_glm_6 <- glm(nclaims ~ age + sex + age:sex + codposs + agecar + fuelc + split + sportc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_6) #AIC = 126145 model 4 is  a better fit

freq_glm_7 <- glm(nclaims ~ age + sex + age:sex + codposs + agecar + fuelc + split + fleetc + sportc + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_7) #AIC = 126225.2 model 4 is  a better fit

freq_glm_8 <- glm(nclaims ~ age + sex + age:sex + codposs + agecar + split + fleetc + sportc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_8) #AIC = 126243.5 model 4 is a better fit

freq_glm_9 <- glm(nclaims ~ age + sex + age:sex + codposs + fuelc + split + fleetc + sportc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_9) #AIC = 126196.3 model 4 is a better fit

freq_glm_10 <- glm(nclaims ~ age + sex + age:sex + agecar + fuelc + split + fleetc + sportc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_10) #AIC = 126247.4 model 4 is a better fit

freq_glm_11 <- glm(nclaims ~ age + sex + age:sex + codposs + agecar + fuelc + split + fleetc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_11) #AIC = 126143.1 this model is a better fit

freq_glm_12 <- glm(nclaims ~ age + sex + age:sex + codposs + agecar + fuelc + split + fleetc + coverp, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_12) #AIC = 126172.3 model 11 is a better fit

freq_glm_13 <- glm(nclaims ~ age + sex + age:sex, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_13) #AIC =  126873.1 model 11 is a better fit

freq_glm_14 <- glm(nclaims ~ age + sex + age:sex + codposs + agecar + fuelc + fleetc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_14) #AIC = 126494.5 model 11 is a better fit

freq_glm_15 <- glm(nclaims ~ age + sex + age:sex + codposs + agecar + fuelc + agecar:fuelc + split + fleetc + coverp + powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_15) #AIC = 126132.7 this model is a better fit

freq_glm_16 <- glm(nclaims ~ age + sex + age:sex + codposs + agecar + fuelc + agecar:fuelc + split + fleetc + coverp + powerc + sex:powerc, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_16) #AIC = 126131.2 this model is a better fit

freq_glm_17 <- glm(nclaims ~ age + sex  + codposs + agecar + fuelc + agecar:fuelc + split + fleetc + coverp + powerc + age:sex+ sex:powerc + age:codposs, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_17) #AIC = 126132.9 model 16 is a better fit

freq_glm_18 <- glm(nclaims ~ age + sex  + codposs + agecar + fuelc  + split + fleetc + coverp + powerc + age:sex+ agecar:fuelc+ sex:powerc + age:split, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_18) #AIC = 126108.6 this model is a better fit

freq_glm_19 <- glm(nclaims ~ age + sex  + codposs + agecar + fuelc  + split + fleetc + coverp + powerc + age:sex+ agecar:fuelc+ sex:powerc + age:split + age:agecar, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_19) #AIC = 126104.3 this model is a better fit

freq_glm_20 <- glm(nclaims ~ age + sex  + codposs + agecar + fuelc  + split + fleetc + coverp + powerc + age:sex+ agecar:fuelc+ sex:powerc + age:split + age:agecar + fuelc:coverp, offset =log(expo), family =poisson(link = "log"),
                  data = mtpl)
AIC(freq_glm_20) #AIC = 126106.2 model 19 is a better fit
```

If we shortly describe our thought process while determening the model. We firstly used all the covariates for fitting the number of claims. Than in individual models we left out one of the covariates, to see if all of them make a significant difference in our modeled variable. The ones that did not make a significat impact on our frequeny, we left out. Than we also tried some interations between covariates. We tried the ones that we thought that are most important. Everytime that we got a model that was better than one before (so it had lower AIC) we build on that model, so that we really tried to get the best possible model we could. 

```{r, echo=F}
AIC_freq <- data.frame(model_name = numeric(0), model = numeric(0), AIC = numeric(0))
for(i in 1:20){
  AIC_freq[i,] <- c(paste("freq_glm_",i, sep =""), 0 ,round(AIC(get(paste("freq_glm_",i, sep =""))),1) ) 
}
AIC_freq$model <- c("1 + age + sex + codposs + agecar + fuelc + split + usec + fleetc + sportc + coverp + powerc","1 + age + codposs + agecar + fuelc + split + usec + fleetc + sportc + coverp + powerc"," 1 + age + sex + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc","1 + age + sex + age:sex + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc","1 + age + sex + age:sex + age:powerc + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc","1 + age + sex + age:sex + codposs + agecar + fuelc + split + sportc + coverp + powerc","1 + age + sex + age:sex + codposs + agecar + fuelc + split + fleetc + sportc + powerc","1 + age + sex + age:sex + codposs + agecar + split + fleetc + sportc + coverp + powerc","1 + age + sex + age:sex + codposs + fuelc + split + fleetc + sportc + coverp + powerc","1 + age + sex + age:sex + agecar + fuelc + split + fleetc + sportc + coverp + powerc","1 + age + sex + age:sex + codposs + agecar + fuelc + split + fleetc + coverp + powerc","1 + age + sex + age:sex + codposs + agecar + fuelc + split + fleetc + coverp","1 + age + sex + age:sex","1 + age + sex + age:sex + codposs + agecar + fuelc + fleetc + coverp + powerc","1 + age + sex + age:sex + codposs + agecar + fuelc + agecar:fuelc + split + fleetc + coverp + powerc","1 + age + sex + age:sex + codposs + agecar + fuelc + agecar:fuelc + split + fleetc + coverp + powerc + sex:powerc","1 + age + sex  + codposs + agecar + fuelc + agecar:fuelc + split + fleetc + coverp + powerc + age:sex+ sex:powerc + age:codposs","1 + age + sex  + codposs + agecar + fuelc  + split + fleetc + coverp + powerc + age:sex+ agecar:fuelc+ sex:powerc + age:split","1 + age + sex  + codposs + agecar + fuelc  + split + fleetc + coverp + powerc + age:sex+ agecar:fuelc+ sex:powerc + age:split + age:agecar","1 + age + sex  + codposs + agecar + fuelc  + split + fleetc + coverp + powerc + age:sex+ agecar:fuelc+ sex:powerc + age:split + age:agecar + fuelc:coverp")
min_AIC_freq = 1
for(i in 2:20){
  if (AIC_freq$AIC[i-1] > AIC_freq$AIC[i]){
    min_AIC_freq <- i
  } else{min_AIC_freq = min_AIC_freq}
}

kable(head(AIC_freq, n = 23), align = "c")
```

And now we can select the model with lowest AIC as the best model amoung our models for the frequency fitting. And this model is shown in the table below.

```{r, echo=F}
kable(AIC_freq[min_AIC_freq,], align = "c")
```

Now we have fitted frequency. But to determin the pure premium we also have to fit severity of claims in our portfolio. We did that with the same thought process as for severity. 

```{r, echo=F, results="hide", fig.show='hide'}
sev_glm_1 <- glm(amount ~ age + sex + codposs + agecar + fuelc + split + usec + fleetc + sportc + coverp + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_1) #AIC = 303002.9

sev_glm_2 <- glm(amount ~ age + codposs + agecar + fuelc + split + usec + fleetc + sportc + coverp + powerc,  family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_2) #AIC = 303043.7 model 1 is a better fit

sev_glm_3 <- glm(amount ~ age + sex + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_3) #AIC = 303000.9 this model is a better fit

sev_glm_4 <- glm(amount ~ age + sex + age:sex + codposs + agecar + fuelc + split  + fleetc + sportc + coverp + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_4) #AIC = 303002.6  model 3 is a better fit

sev_glm_4 <- glm(amount ~ age + sex  + codposs + agecar + fuelc + split  + fleetc + sportc + coverp + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_4) #AIC = 307978.1 this model is a better fit

sev_glm_5 <- glm(amount ~ age + sex  + codposs + agecar + fuelc + split + sportc + coverp + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_5) #AIC = 303000.9 model 3 is  a better fit

sev_glm_6 <- glm(amount ~ age + sex  + codposs + agecar + fuelc + split + fleetc + sportc + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_6) #AIC = 303005.8 model 3 is  a better fit

sev_glm_7 <- glm(amount ~ age + sex + codposs + agecar + split + fleetc + sportc + coverp + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_7) #AIC = 303083.7 model 3 is a better fit

sev_glm_8 <- glm(amount ~ age + sex  + codposs + fuelc + split + fleetc + sportc + coverp + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_8) #AIC = 303039.2 model 3 is a better fit

sev_glm_9 <- glm(amount ~ age + sex  + agecar + fuelc + split + fleetc + sportc + coverp + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_9) #AIC = 303082.6 model 3 is a better fit

sev_glm_10 <- glm(amount ~ age + sex  + codposs + agecar + fuelc + split + fleetc + coverp + powerc, family =Gamma(link = "log"),data = mtpl)
AIC(sev_glm_10) #AIC = 303059.4 model 3 is a better fit

sev_glm_11 <- glm(amount ~ age + sex  + codposs + agecar + fuelc + split  + fleetc + sportc + coverp, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_11) #AIC = 303002.1 model 3 is a better fit

sev_glm_12 <- glm(amount ~ age + sex , offset =log(expo), family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_12) #AIC =  303020.4 model 3 is a better fit

sev_glm_13 <- glm(amount ~ age + sex  + codposs + agecar + fuelc + fleetc + sportc + coverp + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_13) #AIC = 309183.1 model 3 is a better fit 

sev_glm_14 <- glm(amount ~ age + sex + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc, family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_14) #AIC = 303177.9 model 3 is a better fit

sev_glm_15 <- glm(amount ~ age + sex  + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc + sex:powerc, family = Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_15) #AIC = 303000.9 this model is a better fit
sev_glm_16 <- glm(amount ~ age + sex  + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc + sex:powerc , family = Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_16) #AIC = 302931.3 model 15 is a better fit

sev_glm_17 <- glm(amount ~ age + sex  + codposs + agecar + fuelc + agecar:fuelc + split + fleetc + sportc + coverp + powerc + sex:powerc +age:split, family = Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_17) #AIC = 302908.5 this model is a better fit

sev_glm_18 <- glm(amount ~ age + sex + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc + sex:powerc +age:split + fleetc:sportc, family = Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_18) #AIC = 302914.1 model 17 is a better fit

sev_glm_19 <- glm(amount ~ age + sex  + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc + sex:powerc  + age:split , family =Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_19) #AIC = 302913  model 17 is a better fit

sev_glm_20 <- glm(amount ~ age + sex  + codposs + agecar + fuelc  + split + fleetc + sportc + coverp + powerc + sex:powerc  + age:split + codposs:powerc, family = Gamma(link = "log"),
                  data = mtpl)
AIC(sev_glm_20) #AIC = 302906.1 this model is a better fit
```

In the table we show our 20 selected models. 

```{r, echo=F}
AIC_sev <- data.frame(model_name = numeric(0), model = numeric(0), AIC = numeric(0))
for(i in 1:20){
  AIC_sev[i,] <- c(paste("sev_glm_",i, sep =""), 0 ,round(AIC(get(paste("sev_glm_",i, sep =""))),1) ) 
}

AIC_sev$model <- c("1 + age + sex + codposs + agecar + fuelc + split + usec + fleetc + sportc + coverp + powerc","1 + age + codposs + agecar + fuelc + split + usec + fleetc + sportc + coverp + powerc","1+ age + sex + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc","1 + age + sex + age:sex + codposs + agecar + fuelc + split  + fleetc + sportc + coverp + powerc","1 + age + sex  + codposs + agecar + fuelc + split + sportc + coverp + powerc","1 + age + sex  + codposs + agecar + fuelc + split + fleetc + sportc + powerc","1 + age + sex + codposs + agecar + split + fleetc + sportc + coverp + powerc","1 + age + sex  + codposs + fuelc + split + fleetc + sportc + coverp + powerc","1 + age + sex  + agecar + fuelc + split + fleetc + sportc + coverp + powerc","1 + age + sex  + codposs + agecar + fuelc + split + fleetc + coverp + powerc","1 + age + sex  + codposs + agecar + fuelc + split  + fleetc + sportc + coverp","1 + age + sex","1 + age + sex  + codposs + agecar + fuelc + fleetc + sportc + coverp + powerc","1 + age + sex + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc","1 + age + sex  + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc + sex:powerc","1 + age + sex  + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc + sex:powerc","1 + age + sex  + codposs + agecar + fuelc + agecar:fuelc + split + fleetc + sportc + coverp + powerc + sex:powerc +age:split","1 + age + sex + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc + sex:powerc +age:split + fleetc:sportc","1 + age + sex  + codposs + agecar + fuelc + split + fleetc + sportc + coverp + powerc + sex:powerc  + age:split","1 + age + sex  + codposs + agecar + fuelc  + split + fleetc + sportc + coverp + powerc + sex:powerc  + age:split + codposs:powerc")

min_AIC_sev = 1
for(i in 2:20){
  if (AIC_sev$AIC[i-1] > AIC_sev$AIC[i]){
    min_AIC_sev <- i
  } else{min_AIC_sev = min_AIC_sev}
}

kable(head(AIC_sev, n = 23), align = "c")
```

And the model with the lowest AIC is the following model.

```{r, echo=F}
kable(AIC_sev[min_AIC_sev,], align = "c")

```

To get pure premium we need to combine frequency and severity. We need to calculated expected frequency and expected sevirity and then multiply them. This expected frequency and expected sevirity need to be calculated for some risk profiles (ie. some combinations of covariates) that we defined earlier. For each we will use the one with the lowest AIC as it is the best fit. For frequency this is `freq_glm_19` and for severity `sev_glm_20`. Now lets calculated their expected values with function `predict` of type `response`.

```{r, echo=F}
expected_frequency <- mean(predict(freq_glm_19, newdata = NULL, 
       type = "response"))
expected_severity <- mean(predict(sev_glm_20, newdata = NULL, 
       type = "response"))
head(c("Expected frequency" = expected_frequency, "Expected severity" = expected_severity))
```

We see that expected frequency is equal to 0.1239788 and expected sevirty 2527.4901645 EUR (or some other currency). If we multiply this two values we will get the pure premium that we are looking for.

```{r, echo=F}
pure_premium = expected_frequency * expected_severity
head(c("Pure premium" = pure_premium))
```


#4. Demonstration of the calculation of a safety (or risk) loading on top of the pure premiums.

The risk premium of a policy is the sum of the pure premium and the risk loading. In the classification ratemaking process, generalized linear models are usually used to calculate pure premiums, and various premium principles are applied to derive the risk loadings.  No matter which premium principle is used, some risk loading parameters should be given in advance subjectively. To overcome this subjective problem and calculate the risk premium more reasonably and objectively, we propose a top-down method to calculate these risk loading parameters. First, we implement the bootstrap method to calculate the total risk premium of the portfolio. Then, under the constraint that the portfolio’s total risk premium should equal the sum of the risk premiums of each policy, the risk loading parameters are determined.

In Solvency II regulation, the probability that the aggregate claim amount of the whole portfolio 
$$ S = \sum_{i = 1}^{N}Y_{i}$$
(where $Y_{i}$ denotes the aggregate claim amount for individual policy i) exceeds its total risk premium that the insurance company will charge should be controlled in a small range, such as less that 0.5%.
For the whole portfolio, suppose that the aggregate claim amount S has the cumulative distribution function $F_{S}$ and its total risk premiumis denoted by C; then, the probability that the aggregate claim amount of the whole portfolio exceeds its total risk premium is given by
$$ \Phi = Pr[S > C] = 1 - F_{S}(C)  $$
From this equation we obtain the total risk premium of the whole portfolio as
$$ C = F_{S}^{-1}(1 - \Phi) $$
where  $ F_{S}^{-1}(\epsilon) $ denotes the ε-th quantile of S.

We will use a bootstrap method to calculate the total risk premium of the whole portfolio. First, We generate a sequence of pseudo individual aggregate claim amounts and
then predict the total risk premium of the whole portfolio according to the following procedure.
Step 1: Simulate a pseudo-response of the aggregate claim amount ˜yi for policy i from density function $f_{Y_{i}}(y_{i}| \mu_{i},p_{i}, \sigma_{i}) $, i = 1,..., N (N in our case 163,657). 
Step 2: Use the pseudo-responses to form the  $b^{th}$ bootstrap sample to do the bootstrap replication of parameters.We will do this with a `boot` function implemented in Rstudio. 
STep 3:  Repeating these two steps for b = 1, ..., B, we obtain a predictive distribution of aggregate claim amounts for the whole portfolio. As a result, the total risk premium for the whole portfolio is the (1 − Ψ)-th quantile of the aggregate claim amount for the whole portfolio, and the total pure
premium for the whole portfolio is the mean of the aggregate of claim amount for the whole portfolio. The total risk loading for the whole portfolio is calculated by the difference between the total risk premium and the total pure premium.

We will demonstrate the calculation on glm model. 
```{r, echo=F}
library(boot)
mtpl[is.na(mtpl)] <- 0
bs <- function(formula, data, indices){
  d <- data[indices, ] #allows boot to select sample
  fit <- glm(formula, data = d)
  return(coef(fit))
}
bootobject <- boot(data = mtpl, statistic = bs, R = 1000, formula = amount ~ age + sex  + codposs + agecar + fuelc  + split + fleetc + sportc + coverp + powerc + sex:powerc  + age:split + codposs:powerc )
#bootobject

plot(bootobject)

```

Upper graph representsthe distribution of total risk claims. And with 99.5 % quantile we will get the total risk premium.
```{r, echo=F}
quantile(bootobject$t0, 0.995)
```

So our risk premium is equal to  525.64. As our pure premium is equal to 221.29, the risk loading is equal to the difference, so risk loading is equal to 301.35.
We leave a room for a possible mistake in calculation, because usually risk loading is a small percentage of pure premium, but in our case it is larger than the pure premium. 